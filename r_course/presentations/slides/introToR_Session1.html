<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>introToR_Session1.utf8</title>
    <meta charset="utf-8" />
    <meta name="author" content="Rockefeller University, Bioinformatics Resource Centre" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="metropolisCustom.css" type="text/css" />
    <link rel="stylesheet" href="metropolis-fontsCustom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Introduction to R, Session 1
<html>
<div style="float:left">

</div>
<hr color='#EB811B' size=1px width=796px>
</html>
### Rockefeller University, Bioinformatics Resource Centre
### <a href="http://rockefelleruniversity.github.io/Intro_To_R_1Day/" class="uri">http://rockefelleruniversity.github.io/Intro_To_R_1Day/</a>

---




## Overview

- [Set up](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#Set-up)
- [Background to R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#Background-to-R)
- [Data types in R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#datatypes)
- [Reading and writing in R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#datatypes)

---
class: inverse, center, middle


# Set up


&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---
## Materials

All prerequisites, links to material and slides for this course can be found on github.

* [Intro_To_R_1](https://rockefelleruniversity.github.io/Intro_To_R_1Day/)

Or can be downloaded as a zip archive from here.

* [Download zip](https://github.com/rockefelleruniversity/Intro_To_R_1Day/zipball/master)

---
## Presentations, source code and practicals

Once the zip file in unarchived. All presentations as HTML slides and pages, their R code and HTML practical sheets will be available in the directories underneath.

* **presentations/slides/**
Presentations as an HTML slide show.
* **presentations/singlepage/** 
Presentations as an HTML single page.
* **presentations/rcode/**
R code in presentations.
* **exercises/**
Practicals as HTML pages. 
* **answers/**
Practicals with answers as HTML pages and R code solutions. 


---
## Set the Working directory


Before running any of the code in the practicals or slides we need to set the working directory to the folder we unarchived. 

You may navigate to the unarchived Intro_To_R_1Day folder in the Rstudio menu.

**Session -&gt; Set Working Directory -&gt; Choose Directory**

or in the console.


```r
setwd("/PathToMyDownload/Intro_To_R_1Day/r_course")
# e.g. setwd("~/Downloads/Intro_To_R_1Day/r_course")
```



---
class: inverse, center, middle

# Background to R

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---
## What is R?


**R** is a scripting language and environment for **statistical computing**.


Developed by [Robert Gentleman](http://www.gene.com/scientists/our-scientists/robert-gentleman) and [Ross Ihaka](https://www.stat.auckland.ac.nz/~ihaka/). 


Inheriting much from **S** (Bell labs).

- Suited to high level data analysis
- Open source &amp; cross platform
- Extensive graphics capabilities
- Diverse range of add-on packages
- Active community of developers
- Thorough documentation


---
## What is R to you?

.pull-left[

**R** comes with excellent "out-of-the-box" statistical and plotting capabilities.


**R** provides access to 1000s of packages ([CRAN](http://cran.r-project.org/)/[MRAN](http://mran.revolutionanalytics.com/)/[R-forge](https://r-forge.r-project.org/)) which extend the basic functionality of R while maintaining high quality documentation.


In particular, [Robert Gentleman](http://www.gene.com/scientists/our-scientists/robert-gentleman) developed the **[Bioconductor](http://bioconductor.org/)** project where 100's of packages are directly related to computational biology and analysis of associated high-throughput experiments.
  ] 
.pull-right[
![R use over time](imgs/RCitations.jpeg)

  ]

---
## How to get R?

.pull-left[

Freely available from [R-project website](http://cran.ma.imperial.ac.uk/).

RStudio provides an integrated development environment (IDE) which is freely available from [RStudio site](http://www.rstudio.com/)


***We will be using RStudio and R already installed on your machines.***
  ]
.pull-right[
![R website](imgs/cran.jpeg)
![RStudio website](imgs/rstudio.jpeg)
  ]

---
## A quick tour of RStudio

.pull-left[
Four main panels
- Scripting panel
- R interface
- Environment and history
- Files, directories and help


**Let's load RStudio and take a look**
  ]

.pull-right[

![RStudio appearance](imgs/rstudioBlank.jpeg)


  ]

---
class: inverse, center, middle
# Data types in R

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Different Data types in R


- Simple calculations
- Variables
- Vectors
- Lists
- Matrices
- Data frames


---
## Simple Calculations 

At its most basic, **R** can be used as a simple calculator.

```r
&gt; 3+1
```

```
## [1] 4
```

```r
&gt; 2*2
```

```
## [1] 4
```

```r
&gt; sqrt(25)-1
```

```
## [1] 4
```


---
## Using functions

The **sqrt(25)** demonstrates the use of functions in R. A function performs a complex operation on it's arguments and returns the result.

In R, arguments are provided to a function within the parenthesis -- **( )** -- that follows the function name. So **sqrt(*ARGUMENT*)** will provide the square root of the value of ***ARGUMENT***.

Other examples of functions include **min()**, **sum()**, **max()**. 

Note multiple arguments are separated by a comma.


```r
min(2,4,6)
```

```
## [1] 2
```

```r
sum(2,4,6)
```

```
## [1] 12
```

```r
max(2,4,6)
```

```
## [1] 6
```


---
## Using functions


R has many useful functions "built in" and ready to use as soon as R is loaded.

An incomplete, illustrative list can be seen [here](http://www.statmethods.net/management/functions.html) 

In addition to R standard functions, additional functionality can be loaded into R using libraries. These include specialised tools for areas such as sequence alignment, read counting etc.

If you need to see how a function works try **?** in front of the function name.

```r
?sqrt
```


Lets run [**?sqrt**](https://stat.ethz.ch/R-manual/R-devel/library/base/html/MathFun.html) in RStudio and look at the help.


---
## Using functions
**Arguments have names and order**

With functions such as min() and sqrt(), the arguments to be provided are obvious and the order of these arguments doesnt matter.


```r
min(5,4,6)
```

```
## [1] 4
```

```r
min(6,4,5)
```

```
## [1] 4
```

Many functions however have an order to their arguments.
Try and look at the arguments for the dir() function using [?dir](https://stat.ethz.ch/R-manual/R-devel/library/base/html/list.files.html).

```
?dir
```

---
## Using functions
**Setting names for arguments**

Often we know the names of arguments but not necessarily their order.
In cases where we want to be sure we specify the right argument, we provide names for the arguments used.


```r
dir()
dir(full.names=T)
```

This also means we don't have to copy out all the defaults for arguments preceeding it.


```r
dir(full.names=T)
# Is equivalent to...
dir(".",NULL,FALSE,T)
```

---
## Variables 


As with other programming languages and even graphical calculators, **R** makes use of **variables**.

A **variable** stores a value as a letter or word.

In **R**, we make use of the assignment operator **&lt;-** 

```r
x &lt;- 10
```
Now **x** holds the value of 10

```r
x
```

```
## [1] 10
```


---
## Variables



```r
x
```

```
## [1] 10
```

Variables can be altered in place

```r
x &lt;- 20
x
```

```
## [1] 20
```

---

## Variables                                                                                        

Variables can be used just as the values they contain.

```r
x
```

```
## [1] 20
```


```r
x + sqrt(25)
```

```
## [1] 25
```
Variables can be used to create new variables

```r
y &lt;- x + sqrt(25)
y
```

```
## [1] 25
```

---
## Vectors

In **R** the most basic variable or data type is a **vector**. A vector is an ordered collection of values. The x and y variables we have previously assigned are examples of a vector of length 1.


```r
x
```

```
## [1] 20
```

```r
length(x)
```

```
## [1] 1
```

---
## Vectors

To create a multiple value vector we use the function **c()** to *combine* the supplied arguments into one vector.


```r
x &lt;- c(1,2,3,4,5,6,7,8,9,10)
x
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
length(x)
```

```
## [1] 10
```


---
## Vectors

Vectors of continuous stretches of values can be created by the shortcut - **:**


```r
y &lt;- 6:10
y
```

```
## [1]  6  7  8  9 10
```

Other useful function to create stretchs of numeric vectors are **seq()** and **rep()**.
The **seq()** function creates a sequence of numeric values from a specified start and end value, incrementing by a user defined amount. The **rep()** function repeats a variable a user-defined number of times.



```r
seq(from=1,to=5,by=2)
```

```
## [1] 1 3 5
```

```r
rep(c(1,5,10),3)
```

```
## [1]  1  5 10  1  5 10  1  5 10
```


---
## Vectors - Indexing 

Square brackets **[]** identify the position within a vector (the **index**).
These indices can be used to extract relevant values from vectors.



```r
x
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
x[1]
```

```
## [1] 1
```

```r
x[8]
```

```
## [1] 8
```

---
## Vectors - Indexing 


Indices can be used to extract values from multiple positions within a vector.


```r
x[c(1,6)]
```

```
## [1] 1 6
```
Negative indices can be used to extract all positions except that specified.


```r
x[-5]
```

```
## [1]  1  2  3  4  6  7  8  9 10
```



---
## Vectors - Indexing and replacement


We can use indices to modify a specific position in a vector.


```r
x
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
x[5] &lt;- -5
x
```

```
##  [1]  1  2  3  4 -5  6  7  8  9 10
```


---
## Vectors - Indexing and replacement

Indices can be specified using other vectors.


```r
y
```

```
## [1]  6  7  8  9 10
```

```r
x[y] &lt;- 0
x
```

```
##  [1]  1  2  3  4 -5  0  0  0  0  0
```


---
## Remember!


Square brackets **[]**  for indexing.

```r
x[1]
```

```
## [1] 1
```

Parentheses **()**  for function argments.

```r
sqrt(4)
```

```
## [1] 2
```


---
## Vectors - Arithmetic operations 


Vectors in R can be used in arithmetic operations as seen with [variables earlier](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#/simplecalc). When a standard arithmetic operation is applied to vector, the operation is applied to each position in a vector.


```r
x &lt;- c(1,2,3,4,5,6,7,8,9,10)
x
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
y &lt;- x*2
y
```

```
##  [1]  2  4  6  8 10 12 14 16 18 20
```

Multiple vectors can be used within arithmetic operations. 

```r
x+y
```

```
##  [1]  3  6  9 12 15 18 21 24 27 30
```

---
## Vectors - Arithmetic operations  


When applying an arithmetic operation between two vectors of unequal length, the shorter will be recycled.


```r
x &lt;- c(1,2,3,4,5,6,7,8,9,10)
x
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
x+c(1,2)
```

```
##  [1]  2  4  4  6  6  8  8 10 10 12
```


```r
x+c(1,2,3)
```

```
## Warning in x + c(1, 2, 3): longer object length is not a multiple of shorter object length
```

```
##  [1]  2  4  6  5  7  9  8 10 12 11
```


---
## Vectors - Character vectors

So far we have only looked at numeric vectors or variables.

In R we can also create character vectors [again using **c()** function](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#/combine). These vectors can be indexed just the same.


```r
y &lt;- c("ICTEM","CommonWealth","Wolfson")
y[2]
```

```
## [1] "CommonWealth"
```

Character vectors can be used to assign names to other vectors.


```r
x &lt;- c(1:3)
names(x) &lt;- y
x
```

```
##        ICTEM CommonWealth      Wolfson 
##            1            2            3
```

---
## Vectors - Character vectors as names


These named vectors maybe indexed by a position's "name".

```r
x[c("ICTEM","Wolfson")]
```

```
##   ICTEM Wolfson 
##       1       3
```
  
Index names missing from vectors will return special value "NA".

```r
x[c("Strand")]
```

```
## &lt;NA&gt; 
##   NA
```


---
## A note on NA values

In R, like many languages, when a value in a variable is missing, the value is assigned a **NA** value.

Similarly, when a calculation can not be perfomed, R will input a **NaN** value.

- **NA** - Not Available.
- **NaN** - Not A Number.

**NA** values allow for R to handle missing data correctly but requires different handling than standard numeric or character values. We will illustrate an example handling **NA** values [later](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#/nalast).


---
## Vectors - The unique() function


The unique() function can be used to retrieve all unique  values from a vector.


```r
geneList &lt;- c("Gene1","Gene2","Gene3","Gene4","Gene5","Gene1","Gene3")
unique(geneList)
```

```
## [1] "Gene1" "Gene2" "Gene3" "Gene4" "Gene5"
```


---
## Vectors - Logical vectors


Logical vectors are a class of vector made up of TRUE or FALSE boolean values (single letter T/F can also be used).


```r
z &lt;-  c(TRUE,FALSE,TRUE,FALSE,TRUE,FALSE,TRUE,FALSE,TRUE,FALSE) 
# or
z &lt;- c(T,F,T,F,T,F,T,F,T,F) 

z
```

```
##  [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE
```
Logical vectors can be used like an index to specify postions in a vector. TRUE values will return the corresponding position in the vector being indexed.


```r
x &lt;- 1:10
x[z]
```

```
## [1] 1 3 5 7 9
```

---
## Vectors - The %in% operator

A common task in R is to subset one vector by the values in another vector.

The **%in%** operator in the context **A %in% B** creates a logical vector of whether values in **A** matches any values in of **B**.

This can be then used to subset the values within one character vector by a those in a second. 


```r
geneList &lt;- c("Gene1","Gene2","Gene3","Gene4","Gene5","Gene1","Gene3")
secondGeneList &lt;- c("Gene5","Gene3")
logical_index &lt;- geneList %in% secondGeneList
logical_index
```

```
## [1] FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE
```

```r
geneList[logical_index]
```

```
## [1] "Gene3" "Gene5" "Gene3"
```


---
## Vectors - Logical vectors from operators

Vectors may be evaluated to produce logical vectors. This can be very useful when using a logical to index.

Common examples are:

- **==**  evaluates as equal.
- **&gt;** and **&lt;** evaluates as greater or less than respectively.
- **&gt;=** and **&lt;=** evaluates as greater than or equal or less than or equal respectively.


```r
x &lt;- 1:10
x &gt; 5
```

```
##  [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE
```

```r
x[x &gt; 5]
```

```
## [1]  6  7  8  9 10
```


---
## Vectors - Combining logical vectors

Logical vectors can be used in combination in order to index vectors. To combine logical vectors we can use some common R operators.

- **&amp;** - Requires both logical operators to be TRUE
- **|** - Requires either logical operator to be TRUE.
- **!** - Reverses the logical operator, so TRUE is FALSE and FALSE is TRUE.


```r
x &lt;- 1:10
!x &gt; 4
```

```
##  [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
```

```r
x &gt; 4 &amp; x &lt; 7
```

```
##  [1] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE
```

```r
x &gt; 4 | x &lt; 7
```

```
##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
```


---
## Vectors - Combining logical vectors

Such combinations can allow for complex selection of a vector's values.

```r
x &lt;- 1:10
x
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
x[x &gt; 4 &amp; x &lt; 7]
```

```
## [1] 5 6
```

```r
x[x &gt; 4 &amp; !x &lt; 7]
```

```
## [1]  7  8  9 10
```

---
## Time for an exercise!


Exercise on vectors can be found [here](http://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/exercises/vector_exercise.html)


---
## Answers to exercise.


Answers can be found here  [here](http://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/answers/vector_answers.html)

R code for solutions can be found here  [here](http://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/answers/vector_answers.R)


---
## Matrices - Creating matrices


In programs such as Excel, we are used to tables.

&lt;div align="center"&gt;
&lt;img src="imgs/ExcelMat2.png" alt="igv" height="300" width="600"&gt;
&lt;/div&gt;

---
## Matrices - Creating matrices

All progamming languages have a concept of a table. In **R**, the most basic table type is a **matrix**.

A **matrix** can be created using the ***matrix()*** function with the arguments of **nrow** and **ncol** specifying the number of rows and columns respectively.

```r
narrowMatrix &lt;- matrix(1:10, nrow=5, ncol=2)
narrowMatrix
```

```
##      [,1] [,2]
## [1,]    1    6
## [2,]    2    7
## [3,]    3    8
## [4,]    4    9
## [5,]    5   10
```

```r
wideMatrix &lt;- matrix(1:10, nrow=2, ncol=5)
wideMatrix
```

```
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10
```


---
## Matrices - Creating matrices


By default when creating a matrix using the **matrix** function, the values fill the matrix by columns. To fill a matrix by rows the **byrow** argument must be set to TRUE.


```r
wideMatrix &lt;- matrix(1:10, nrow=2, ncol=5)
wideMatrix
```

```
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10
```

```r
wideMatrixByRow &lt;- matrix(1:10, nrow=2, ncol=5, byrow=TRUE)
wideMatrixByRow
```

```
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    2    3    4    5
## [2,]    6    7    8    9   10
```


---
## Matrices - Finding dimensions


To find dimensions of a matrix, the **dim()** function will provide dimensions as the row then column number while **nrow()** and **ncol()** will return just row number and column number respectively.

```r
dim(narrowMatrix)
```

```
## [1] 5 2
```

```r
nrow(narrowMatrix)
```

```
## [1] 5
```

```r
ncol(narrowMatrix)
```

```
## [1] 2
```


---
## Matrices - Joining vectors and matrices


A matrix can be created from multiple vectors or other matrices.

**cbind()** can be used to attach data to a matrix as columns.

```r
x &lt;- 1:5
y &lt;- 11:15
z &lt;- 21:22
newMatrix &lt;- cbind(x,y)
newMatrix
```

```
##      x  y
## [1,] 1 11
## [2,] 2 12
## [3,] 3 13
## [4,] 4 14
## [5,] 5 15
```

---
## Matrices - Joining vectors and matrices

**rbind()** functions to bind to a matrix as rows.

```r
newerMatrix &lt;- rbind(newMatrix,z)
newerMatrix
```

```
##    x  y
##    1 11
##    2 12
##    3 13
##    4 14
##    5 15
## z 21 22
```


---
## Matrices - Joining vectors and matrices

### Incompatible vectors and matrices

When creating a matrix using **cbind()** or **matrix()** from incompatible vectors then the shorter vector is recycled. 



```r
recycledMatrix2 &lt;- matrix(1:5,ncol=2,nrow=3)
```

```
## Warning in matrix(1:5, ncol = 2, nrow = 3): data length [5] is not a sub-multiple or multiple
## of the number of rows [3]
```

```r
recycledMatrix2
```

```
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    1
```

---
## Matrices - Joining vectors and matrices

### Incompatible vectors and matrices

For **rbind()** function, the longer vector is clipped.

```r
recycledMatrix3 &lt;- rbind(recycledMatrix2,c(1:5))
```

```
## Warning in rbind(recycledMatrix2, c(1:5)): number of columns of result is not a multiple of
## vector length (arg 2)
```

```r
recycledMatrix3
```

```
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    1
## [4,]    1    2
```


---
## Matrices - Column and row names

[As we have seen with vectors](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#/namingvectors), matrices can be named. For matrices the naming is done by columns and rows using **colnames()** and **rownames()** functions.


```r
namedMatrix &lt;- matrix(1:10,ncol=5,nrow=2)
colnames(namedMatrix) &lt;- paste("Column",1:5,sep="_")
rownames(namedMatrix) &lt;- paste("Row",1:2,sep="_")
namedMatrix
```

```
##       Column_1 Column_2 Column_3 Column_4 Column_5
## Row_1        1        3        5        7        9
## Row_2        2        4        6        8       10
```

---
## Matrices - Column and row names

Information on matrix names can also be retreived using the same functions.

```r
colnames(namedMatrix)
```

```
## [1] "Column_1" "Column_2" "Column_3" "Column_4" "Column_5"
```

```r
rownames(namedMatrix)
```

```
## [1] "Row_1" "Row_2"
```



---
## Matrices - Indexing

Selecting and replacing portions of a matrix can be done by **indexing** using square brackets **[]** much [like for vectors](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#indexingvectors).

When indexing matrices, two values may be provided within the square brackets separated by a comma to retrieve information on a matrix position.

The first value(s) corresponds to row(s) and the second to column(s).

- ***myMatrix[rowOfInterest,columnOfInterest]***

---
## Matrices - Indexing


```r
narrowMatrix
```

```
##      [,1] [,2]
## [1,]    1    6
## [2,]    2    7
## [3,]    3    8
## [4,]    4    9
## [5,]    5   10
```
Value of first column, second row

```r
narrowMatrix[2,1]
```

```
## [1] 2
```


---
## Matrices - Indexing 


Similarly, whole rows or columns can be extracted. Single rows and columns will return a vector.  

Values of second column (row index is empty!)

```r
narrowMatrix[,2]
```

```
## [1]  6  7  8  9 10
```

Values of third row (column index is empty!)

```r
narrowMatrix[3,]
```

```
## [1] 3 8
```

---
## Matrices - Indexing 

When multiple columns or row indices are specified, a matrix is returned.

Values of second and third row (column index is empty!)

```r
narrowMatrix[c(2,3),]
```

```
##      [,1] [,2]
## [1,]    2    7
## [2,]    3    8
```

---
## Matrices - Indexing by name

As with vectors, names can be used for indexing when present


```r
colnames(narrowMatrix) &lt;- paste("Column",1:2,sep="_")
rownames(narrowMatrix) &lt;- paste("Row",1:5,sep="_")
narrowMatrix[,"Column_1"]
```

```
## Row_1 Row_2 Row_3 Row_4 Row_5 
##     1     2     3     4     5
```

```r
narrowMatrix["Row_1",]
```

```
## Column_1 Column_2 
##        1        6
```

```r
narrowMatrix["Row_1","Column_1"]
```

```
## [1] 1
```


---
## Matrices - Advanced indexing

As with vectors, matrices can be subset by logical vectors

```r
narrowMatrix
```

```
##       Column_1 Column_2
## Row_1        1        6
## Row_2        2        7
## Row_3        3        8
## Row_4        4        9
## Row_5        5       10
```

```r
narrowMatrix[,1]
```

```
## Row_1 Row_2 Row_3 Row_4 Row_5 
##     1     2     3     4     5
```

```r
narrowMatrix[,1] &lt; 5
```

```
## Row_1 Row_2 Row_3 Row_4 Row_5 
##  TRUE  TRUE  TRUE  TRUE FALSE
```

---
## Matrices - Advanced indexing


```r
narrowMatrix[narrowMatrix[,1] &lt; 5,]
```

```
##       Column_1 Column_2
## Row_1        1        6
## Row_2        2        7
## Row_3        3        8
## Row_4        4        9
```


---
## Matrices - Arithmetic operations.


As with vectors, matrices can have arithmetic operations applied to cells,rows, columns or the whole matrix

```r
narrowMatrix
```

```
##       Column_1 Column_2
## Row_1        1        6
## Row_2        2        7
## Row_3        3        8
## Row_4        4        9
## Row_5        5       10
```

```r
narrowMatrix[1,1]+2
```

```
## [1] 3
```

```r
narrowMatrix[1,]+2
```

```
## Column_1 Column_2 
##        3        8
```

```r
mean(narrowMatrix)
```

```
## [1] 5.5
```


---
## Matrices - Replacement


As with vectors, matrices can have their elements replaced

```r
narrowMatrix
```

```
##       Column_1 Column_2
## Row_1        1        6
## Row_2        2        7
## Row_3        3        8
## Row_4        4        9
## Row_5        5       10
```

```r
narrowMatrix[1,1] &lt;- 10
narrowMatrix[,2] &lt;- 1
narrowMatrix
```

```
##       Column_1 Column_2
## Row_1       10        1
## Row_2        2        1
## Row_3        3        1
## Row_4        4        1
## Row_5        5        1
```


---
## Matrices - Data types

Matrices must be all one type (i.e. numeric or character).

Here replacing one value with character will turn numeric matrix to character matrix.


```r
narrowMatrix[,2] *2
```

```
## Row_1 Row_2 Row_3 Row_4 Row_5 
##     2     2     2     2     2
```

```r
narrowMatrix[1,1] &lt;- "Not_A_Number"
narrowMatrix
```

```
##       Column_1       Column_2
## Row_1 "Not_A_Number" "1"     
## Row_2 "2"            "1"     
## Row_3 "3"            "1"     
## Row_4 "4"            "1"     
## Row_5 "5"            "1"
```

---
## Matrices - Data types


```r
narrowMatrix[,2] *2
```

```
## Error in narrowMatrix[, 2] * 2: non-numeric argument to binary operator
```


---
## Time for an exercise!


Exercise on matrices can be found [here](http://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/exercises/matrices_exercise.html)


---
## Answers to exercise.


Answers can be found here  [here](http://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/answers/matrices_answers.html)

R code for solutions can be found [here](http://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/answers/matrices_answers.R)



---
## Factors - Creating factors


A special case of a vector is a **factor**.

Factors are used to store data which may be grouped in categories (categorical data).
Specifying data as categorical allows R to properly handle the data and make use of functions specific to categorical data.

To create a factor from a vector we use the **factor()** function. Note that the factor now has an additional component called **"levels"** which identifies all categories within the vector.


```r
vectorExample &lt;- c("male","female","female","female")
factorExample &lt;- factor(vectorExample)
factorExample
```

```
## [1] male   female female female
## Levels: female male
```

```r
levels(factorExample)
```

```
## [1] "female" "male"
```


---
## Factors - Summary() function


An example of the use of levels can be seen from applying the **summary()** function to the vector and factor examples



```r
summary(vectorExample)
```

```
##    Length     Class      Mode 
##         4 character character
```

```r
summary(factorExample)
```

```
## female   male 
##      3      1
```



---
## Factors - Display order of levels

In our factor example, the levels have been displayed in an alphabetical order. To adjust the display order of levels in a factor, we can supply the desired display order to **levels** argument in the **factor()** function call.


```r
factorExample &lt;- factor(vectorExample,levels=c("male","female"))
factorExample
```

```
## [1] male   female female female
## Levels: male female
```

```r
summary(factorExample)
```

```
##   male female 
##      1      3
```

---
## Factors - Nominal factors

In some cases there is no natural order to the categories such that one category is greater than the other (nominal data).
In this case we can see that R is gender neutral.


```r
factorExample &lt;- factor(vectorExample,levels=c("male","female"))
factorExample[1] &lt; factorExample[2]
```

```
## Warning in Ops.factor(factorExample[1], factorExample[2]): '&lt;' not meaningful for factors
```

```
## [1] NA
```

---
## Factors - Ordinal factors

In other cases there will be a natural ordering to the categories (ordinal data). A factor can be specified to be ordered using the **ordered** argument in combination with specified levels argument.


```r
factorExample &lt;- factor(c("small","big","big","small"),
                        ordered=TRUE,levels=c("small","big"))
factorExample
```

```
## [1] small big   big   small
## Levels: small &lt; big
```

```r
factorExample[1] &lt; factorExample[2]
```

```
## [1] TRUE
```

---
## Factors - Replacement

Unlike vectors, replacing elements within a factor isn't so easy. While replacing one element with an established level is possible, replacing with a novel element will result in a warning.


```r
factorExample &lt;- factor(c("small","big","big","small"))
factorExample[1] &lt;- c("big")
factorExample
```

```
## [1] big   big   big   small
## Levels: big small
```

```r
factorExample[1] &lt;- c("huge")
```

```
## Warning in `[&lt;-.factor`(`*tmp*`, 1, value = "huge"): invalid factor level, NA generated
```

```r
factorExample
```

```
## [1] &lt;NA&gt;  big   big   small
## Levels: big small
```

---
## Factors - Replacement

To add a new level we can use the levels argument.


```r
levels(factorExample) &lt;- c("big","small","huge")
factorExample[1] &lt;- c("huge")
factorExample
```

```
## [1] huge  big   big   small
## Levels: big small huge
```


---
## Data frames - Creating data frames 

[We saw that with matrices you can only have one type of data](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#/onedatatype). We tried to create a matrix with a character element and the entire matrix became a character.

In practice, we would want to have a table which is a mixture of types (e.g a table with sample names (character), sample type (factor) and survival time (numeric))

&lt;div align="center"&gt;
&lt;img src="imgs/ExcelMat.jpg" alt="igv" height="300" width="600"&gt;
&lt;/div&gt;

---
## Data frames - Creating data frames 

In R, we make use of the **data frame** object which allows us to store tables with columns of different data types. To create a data frame we can simply use the **data.frame()** function.


```r
patientName &lt;- c("patient1","patient2","patient3","patient4")
patientType &lt;- factor(rep(c("male","female"),2))
survivalTime &lt;- c(1,30,2,20)
dfExample &lt;- data.frame(Name=patientName, Type=patientType, Survival_Time=survivalTime)
dfExample
```

```
##       Name   Type Survival_Time
## 1 patient1   male             1
## 2 patient2 female            30
## 3 patient3   male             2
## 4 patient4 female            20
```

---
## Data frames - Indexing and replacement

Data frames may be indexed just [as matrices](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#/indexingmatrices).


```r
dfExample
```

```
##       Name   Type Survival_Time
## 1 patient1   male             1
## 2 patient2 female            30
## 3 patient3   male             2
## 4 patient4 female            20
```

```r
dfExample[dfExample[,"Survival_Time"] &gt; 10,]
```

```
##       Name   Type Survival_Time
## 2 patient2 female            30
## 4 patient4 female            20
```

---
## Data frames - Specify columns with $

Unlike matrices, it is possible to index a column by using the **$** symbol.


```r
dfExample &lt;- data.frame(Name=patientName,Type=patientType,Survival_Time=survivalTime)
dfExample$Survival_Time
```

```
## [1]  1 30  2 20
```

```r
dfExample[dfExample$Survival_Time &lt; 10,]
```

```
##       Name Type Survival_Time
## 1 patient1 male             1
## 3 patient3 male             2
```

---
## Data frames - Specify columns with $

Using the **$** allows for R to autocomplete your selection and so can speed up coding.


```r
dfExample$Surv
```

```
## [1]  1 30  2 20
```
But this will not work..

```r
dfExample[,"Surv"]
```

---
## Data frames - Create columns with $

The **$** operator also allows for the creation of new columns for a data frame on the fly.


```r
dfExample
```

```
##       Name   Type Survival_Time
## 1 patient1   male             1
## 2 patient2 female            30
## 3 patient3   male             2
## 4 patient4 female            20
```

```r
dfExample$newColumn &lt;- rep("newData",nrow(dfExample))
dfExample
```

```
##       Name   Type Survival_Time newColumn
## 1 patient1   male             1   newData
## 2 patient2 female            30   newData
## 3 patient3   male             2   newData
## 4 patient4 female            20   newData
```


---
## Data frames - Indexing and replacement

Certain columns can not be replaced in data frames. Numeric columns may have their values replaced but columns with character values may not by default. 


```r
dfExample[dfExample[,"Survival_Time"] &lt; 10,"Survival_Time"] &lt;- 0
dfExample
```

```
##       Name   Type Survival_Time newColumn
## 1 patient1   male             0   newData
## 2 patient2 female            30   newData
## 3 patient3   male             0   newData
## 4 patient4 female            20   newData
```

---
## Data frames - Indexing and replacement

This occurs because character vectors are treated as factors by default.


```r
dfExample[dfExample[,"Survival_Time"] &lt; 10,"Name"] &lt;- "patientX"
```

```
## Warning in `[&lt;-.factor`(`*tmp*`, iseq, value = c("patientX", "patientX")): invalid factor
## level, NA generated
```

```r
dfExample
```

```
##       Name   Type Survival_Time newColumn
## 1     &lt;NA&gt;   male             0   newData
## 2 patient2 female            30   newData
## 3     &lt;NA&gt;   male             0   newData
## 4 patient4 female            20   newData
```

---
## Data frames - Factors in data frames

It is possible to update factors in data frames just as with standard factors.


```r
dfExample &lt;- data.frame(Name=patientName,Type=patientType,
                        Survival_Time=survivalTime)

levels(dfExample[,"Name"]) &lt;- c(levels(dfExample[,"Name"]) ,
                                "patientX")

dfExample[dfExample[,"Survival_Time"] &lt; 10,"Name"] &lt;- "patientX"
dfExample
```

```
##       Name   Type Survival_Time
## 1 patientX   male             1
## 2 patient2 female            30
## 3 patientX   male             2
## 4 patient4 female            20
```


---
## Data frames - Data frames without factors

If you wish to avoid using factors in data frames then the **stringsAsFactors** argument to **data.frame()** function should be set to **FALSE**


```r
dfExample &lt;- data.frame(Name=patientName,
                        Type=patientType,
                        Survival_Time=survivalTime,
                        stringsAsFactors = F)


dfExample[dfExample[,"Survival_Time"] &lt; 10,"Name"] &lt;- "patientX"
dfExample
```

```
##       Name   Type Survival_Time
## 1 patientX   male             1
## 2 patient2 female            30
## 3 patientX   male             2
## 4 patient4 female            20
```


---
## Data frames - Ordering with order()

A useful function in R is **order()**

For numeric vectors, **order()** by default returns the indices of a vector in that vector's increasing order. This behaviour can be altered by using the "decreasing" argument passed to order.


```r
testOrder &lt;- c(2,1,3)
testOrder
```

```
## [1] 2 1 3
```

```r
testOrder[order(testOrder)]
```

```
## [1] 1 2 3
```

```r
testOrder[order(testOrder,decreasing=T)]
```

```
## [1] 3 2 1
```

---
## Data frames - Ordering with NA values

When a vector contains NA values, these NA values will, by default, be placed last in ordering indices. This can be controlled by **na.last** argument.


```r
testOrder &lt;- c(2,1,NA,3)
testOrder[order(testOrder,decreasing=T,na.last=T)]
```

```
## [1]  3  2  1 NA
```

```r
testOrder[order(testOrder,decreasing=T,na.last=F)]
```

```
## [1] NA  3  2  1
```

---
## Data frames - Ordering data frames 

Since the order argument returns an index of intended order for a vector, we can use the order() function to order data frames by certain columns

```r
dfExample
```

```
##       Name   Type Survival_Time
## 1 patientX   male             1
## 2 patient2 female            30
## 3 patientX   male             2
## 4 patient4 female            20
```

```r
dfExample[order(dfExample$Surv, decreasing=T),]
```

```
##       Name   Type Survival_Time
## 2 patient2 female            30
## 4 patient4 female            20
## 3 patientX   male             2
## 1 patientX   male             1
```

---
## Data frames - Ordering data frames 


We can also use order to arrange multiple columns in a data frame by providing multiple vectors to order() function. Ordering will be performed in order of arguments.


```r
dfExample[order(dfExample$Type,
                dfExample$Survival,
                decreasing=T),]
```

```
##       Name   Type Survival_Time
## 3 patientX   male             2
## 1 patientX   male             1
## 2 patient2 female            30
## 4 patient4 female            20
```


---
## Data frames - Merging data frames

A common operation is to join two data frames by a column of common values.



```r
dfExample &lt;- data.frame(Name=patientName,Type=patientType,
                        Survival_Time=survivalTime)
dfExample 
```

```
##       Name   Type Survival_Time
## 1 patient1   male             1
## 2 patient2 female            30
## 3 patient3   male             2
## 4 patient4 female            20
```



```r
dfExample2 &lt;- data.frame(Name=patientName[1:3],
                        height=c(6.1,5.1,5.5))
dfExample2
```

```
##       Name height
## 1 patient1    6.1
## 2 patient2    5.1
## 3 patient3    5.5
```

---
## Data frames - Merging data frames

To do this we can use the **merge()** function with the data frames as the first two arguments. We can then specify the columns to merge by with the **by** argument. To keep only data pertaining to values common to both data frames the **all** argument is set to FALSE.


```r
mergedDF &lt;- merge(dfExample,dfExample2,by=1,all=F)
mergedDF
```

```
##       Name   Type Survival_Time height
## 1 patient1   male             1    6.1
## 2 patient2 female            30    5.1
## 3 patient3   male             2    5.5
```

---
## Time for an exercise!

Exercise on data frames can be found [here](http://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/exercises/factorsAndDataframes_Exercise.html)


---
## Answers to exercise.

Answers can be found here  [here](http://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/answers/factorsAndDataframes_Answers.html)

R code solutions can be found [here](http://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/answers/factorsAndDataframes_Answers.R)


---
## Lists - Creating lists

Lists are the final data type we will look at. 

In R, lists provide a general container which may hold any data types of unequal lengths as part of its elements.


```r
firstElement &lt;- c(1,2,3,4)
secondElement &lt;- matrix(1:10,nrow=2,ncol=5)
thirdElement &lt;- data.frame(colOne=c(1,2,4,5),colTwo=c("One","Two","Three","Four"))
```
---
## Lists -  lists
To create a list we can simply use the **list()** function with arguments specifying the data we wish to include in the list.


```r
myList &lt;- list(firstElement,secondElement,thirdElement)
myList
```

```
## [[1]]
## [1] 1 2 3 4
## 
## [[2]]
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10
## 
## [[3]]
##   colOne colTwo
## 1      1    One
## 2      2    Two
## 3      4  Three
## 4      5   Four
```

---
## Lists -  Named lists
 
[Just as with vectors](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#/namingvectors), list elements can be assigned names.


```r
myNamedList &lt;- list(First=firstElement,Second=secondElement,
                    Third=thirdElement)
myNamedList
```

```
## $First
## [1] 1 2 3 4
## 
## $Second
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10
## 
## $Third
##   colOne colTwo
## 1      1    One
## 2      2    Two
## 3      4  Three
## 4      5   Four
```

---
## Lists - Indexing

List, as [with other data types in R](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#/indexingvectors) can be indexed. In contrast to other types, using **[]** on a list will subset the list to another list of selected indices. To retrieve an element from a list in R , two square brackets **[[]]** must be used. 


```r
myList &lt;- list(firstElement,secondElement,thirdElement)
myList[1]
```

```
## [[1]]
## [1] 1 2 3 4
```

```r
myList[[1]]
```

```
## [1] 1 2 3 4
```

As with data.frames, the $ sign may be used to extract named elements from a list


```r
myNamedList$First
```

```
## [1] 1 2 3 4
```


---
## Lists - Joining lists


Again, [similar to vectors](https://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/presentations/singlepage/introToR_Session1.html#/combine), lists can be joined together in R using the c() function 


```r
myNamedList &lt;- list(First=firstElement,Second=secondElement,
                    Third=thirdElement)
myNamedList &lt;- c(myNamedList,list(fourth=c(4,4)))
myNamedList[c(1,4)]
```

```
## $First
## [1] 1 2 3 4
## 
## $fourth
## [1] 4 4
```


---
## Lists - Joining vectors to lists

Note that on last slide we are joining two lists. If we joined a vector to a list, all elements of the vector would become list elements.


```r
myList &lt;- c(myList,c(4,4))
myList[3:5]
```

```
## [[1]]
##   colOne colTwo
## 1      1    One
## 2      2    Two
## 3      4  Three
## 4      5   Four
## 
## [[2]]
## [1] 4
## 
## [[3]]
## [1] 4
```

---
## Lists - Flattening lists

Sometimes you will wish to "flatten" out a list. When a list contains compatable objects, i.e. list of all one type, the **unlist()** function can be used. Note the maintenance of names with their additional sufficies.


```r
myNamedList &lt;- list(First=c(1,2,3),Second=c(2,6,7),Third=c(1,4,7))
myNamedList
```

```
## $First
## [1] 1 2 3
## 
## $Second
## [1] 2 6 7
## 
## $Third
## [1] 1 4 7
```

```r
flatList &lt;- unlist(myNamedList)
flatList[1:7]
```

```
##  First1  First2  First3 Second1 Second2 Second3  Third1 
##       1       2       3       2       6       7       1
```



---
## Lists - Flattening lists to matrices

A common step is to turn a list of standard results into matrix. This can be done in a few steps in R, using functions you are now familair with.


```r
myNamedList &lt;- list(First=c(1,2,3),Second=c(2,6,7),Third=c(1,4,7))
flatList &lt;- unlist(myNamedList)
listAsMat &lt;- matrix(flatList,
                    nrow=length(myNamedList),
                    ncol=3,
                    byrow=T,
                    dimnames=list(names(myNamedList)))
listAsMat
```

```
##        [,1] [,2] [,3]
## First     1    2    3
## Second    2    6    7
## Third     1    4    7
```


---
class: inverse, center, middle

#Reading and writing data in R

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---
## Data from external sources

Most of the time, you will not be generating data in R but will be importing data from external files.

A standard format for this data is a table:

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; Gene_Name &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Sample_1.hi &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Sample_2.hi &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Sample_3.hi &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Gene_a &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2.848555 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 7.236719 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.450690 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Gene_b &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4.856318 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 6.198921 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 4.963827 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Gene_c &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2.404432 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.480747 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 5.075056 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Gene_d &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.837149 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 5.869630 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.904781 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Gene_e &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 10.855875 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 8.923983 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 10.022766 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Gene_f &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 9.769767 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 9.102934 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 8.929089 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Gene_g &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 11.219760 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 9.851240 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 8.416511 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; Gene_h &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 11.308259 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 10.702922 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 8.542752 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

---
## Data from text file with read.table()


Tables from text files can be read with **read.table()** function


```r
Table &lt;- read.table("data/readThisTable.csv",sep=",",header=T)
Table[1:4,1:3]
```

```
##   Gene_Name Sample_1.hi Sample_2.hi
## 1    Gene_a    4.570237    3.230467
## 2    Gene_b    3.561733    3.632285
## 3    Gene_c    3.797274    2.874462
## 4    Gene_d    3.398242    4.415202
```

Here we have provided two arguments. 
- **sep** argument specifies how columns are separated in our text file. ("," for .csv, "\t" for .tsv)
- **header** argument specifies whether columns have headers.

---
## Row names in read.table()

read.table() allows for significant control over reading files through its many arguments. Have a look at options by using **?read.table**

The **row.names** argument can be used to specify a column to use as row names for the resulting data frame. Here we use the first column as row names.


```r
Table &lt;- read.table("data/readThisTable.csv",sep=",",header=T,row.names=1)
Table[1:4,1:3]
```

```
##        Sample_1.hi Sample_2.hi Sample_3.hi
## Gene_a    4.570237    3.230467    3.351827
## Gene_b    3.561733    3.632285    3.587523
## Gene_c    3.797274    2.874462    4.016916
## Gene_d    3.398242    4.415202    4.893561
```

---
## Setting factors from read.table()

As mentioned, data which is read into R through read.table() will be of data frame class.

To avoid character columns being converted into factors, we can specify the **stringsAsFactors** argument here.


```r
Table &lt;- read.table("data/readThisTable.csv",sep=",",header=T,stringsAsFactors=F)
```

Other very useful functions for read table include:
- **skip** - To set number of lines to skip when reading.
- **comment.char** - To set the start identifier for lines not to be read.

---
## Data from other sources

The read.table function can also read data from http.


```r
URL &lt;- "http://rockefelleruniversity.github.io/readThisTable.csv"
Table &lt;- read.table(URL,sep=",",header=T)
Table[1:2,1:3]
```

```
##   Gene_Name Sample_1.hi Sample_2.hi
## 1    Gene_a    4.111851    3.837018
## 2    Gene_b    6.047822    5.683518
```
And the clipboard (this is Windows version).


```r
Table &lt;- read.table(file="clipboard",sep=",",header=T)
```

---
## Data from file columns


read.table() function will by default read every row and column of a file.

The **scan()** function allows for the selection of particular columns to be read into R and so can save memory when files are large. 



```r
x &lt;- scan("data/readThisTable.csv",sep=",",
what = c("character",rep("numeric", 6)),skip=1)
x[1:3]
```

```
## [1] "Gene_a"           "4.57023720364456" "3.23046698308814"
```

---
## Writing data to file

Once we have our data analysed in R, we will want to export it to a file. 

The most common method is to use the write.table() function


```r
write.table(Table, file="data/writeThisTable.csv", sep=",")
```

Since our data has column names but no row names, I will provide the arguments col.names and row.names to write.table()


```r
write.table(Table, file="data/writeThisTable.csv", sep=",", row.names =F, col.names=T)
```


---
## The rio (R io) package

We may want to import from formats other than plain text.

We can make use of an R package (the rio package) which allows us to import and export data to mulitple formats.

Formats include:-

* XML
* Matlab, SAS, SPSS and minitab output formats.
* Excel and OpenOffice formats.


---
## The rio package

To make use of the rio package functionality we will need to install this package to our version of R.

We can do this by using the **install.packages()** function with the package we wish to install.

**install.packages(_PACKAGENAME_)**


```r
install.packages("rio")
```

---
## The rio package

Once we have installed a package, we will need to load it to make the functions available to us.

We can load a library by using the **library()** function with package we wish to install

**library(_PACKAGENAME_)**


```r
library("rio")
```

---
## The rio package

The main two functions in the rio package are the **import** and **export** functions.

We can use the **import()** function to read in our csv file. We simple specify our file as an argument to the **import()** function.

**import(_Filename_)**          


```r
Table &lt;- import("data/readThisTable.csv")
Table[1:2,]
```

```
##   Gene_Name Sample_1.hi Sample_2.hi Sample_3.hi Sample_4.low Sample_5.low Sample_1.low
## 1    Gene_a    4.570237    3.230467    3.351827     3.930877     4.098247     4.418726
## 2    Gene_b    3.561733    3.632285    3.587523     4.185287     1.380976     5.936990
```

---
## The rio package

By default we will only retrieve the first sheet.

We can specify the sheet by name or number using the **which** argument.


```r
Table &lt;- import("data/readThisXLS.xls", 
                which=2)
Table &lt;- import("data/readThisXLS.xls", 
                which="Metadata")
Table[1:2,]
```

```
##       Patient Condition   Treatment
## 1 Sample_1.hi         A           X
## 2 Sample_2.hi         A NoTreatment
```

---
## The rio package

If we want to import all sheets, we can use the **import_list**.

This returns a *list* containing our two spreadsheets. The list has two elements named after the corresponding XLS sheet.


```r
Table &lt;- import_list("data/readThisXLS.xls")
names(Table)
```

```
## [1] "ExpressionScores" "Metadata"
```

---
## The rio package

Since this is a list of data.frames, we can access our sheets using standard list accessors, **$** and **[[]]**.


```r
## Table[["ExpressionScores"]][1:2,]
Table$ExpressionScores[1:2,]
```

```
##   Gene_Name Sample_1.hi Sample_2.hi Sample_3.hi Sample_4.low Sample_5.low Sample_1.low
## 1    Gene_a    4.570237    3.230467    3.351827     3.930877     4.098247     4.418726
## 2    Gene_b    3.561733    3.632285    3.587523     4.185287     1.380976     5.936990
```

```r
Table$Metadata[1:2,]
```

```
##       Patient Condition   Treatment
## 1 Sample_1.hi         A           X
## 2 Sample_2.hi         A NoTreatment
```

---
## The rio package

We can export our data back to file using the **export()** function and specifying the name of the output file to the **file** argument. The **export()** function will guess the format required from the extension.


```r
ExpressionScores &lt;- Table$ExpressionScores
export(ExpressionScores,file = "data/writeThisXLSX.xlsx")
```

---
## The rio package

We can export a list of data.frames to Excel's xlsx format using the **export()** function. The names of list elements will be used to name sheets in xlsx file.


```r
names(Table) &lt;- c("expr","meta")
export(Table,file = "data/writeThisMultipleXLSX.xlsx")
```


---
## Time for an exercise!

Exercise on reading and writing data can be found [here](http://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/exercises/DataInputOutput_Exercises.html)

---
## Answers to exercise.

Answers can be found [here](http://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/answers/DataInputOutput_answers.html)

R code for solutions can be found [here](http://rockefelleruniversity.github.io/Intro_To_R_1Day/r_course/answers/DataInputOutput_answers.R)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  /* Replace <script> tags in slides area to make them executable
   *
   * Runs after post-processing of markdown source into slides and replaces only
   * <script>s on the last slide of continued slides using the .has-continuation
   * class added by xaringan. Finally, any <script>s in the slides area that
   * aren't executed are commented out.
   */
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container:not(.has-continuation) script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
  var scriptsNotExecuted = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container.has-continuation script'
  );
  if (!scriptsNotExecuted.length) return;
  for (var i = 0; i < scriptsNotExecuted.length; i++) {
    var comment = document.createComment(scriptsNotExecuted[i].outerHTML)
    scriptsNotExecuted[i].parentElement.replaceChild(comment, scriptsNotExecuted[i])
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
